/* tslint:disable */
/* eslint-disable */
export function runRayonThread(receiver: number): void;
export function initThreadPool(url: URL, num_threads: number): Promise<void>;
/**
 * Public address of an Aleo account
 */
export class Address {
  private constructor();
  free(): void;
  /**
   * Derive an Aleo address from a private key
   *
   * @param {PrivateKey} private_key The private key to derive the address from
   * @returns {Address} Address corresponding to the private key
   */
  static from_private_key(private_key: PrivateKey): Address;
  /**
   * Derive an Aleo address from a view key
   *
   * @param {ViewKey} view_key The view key to derive the address from
   * @returns {Address} Address corresponding to the view key
   */
  static from_view_key(view_key: ViewKey): Address;
  /**
   * Create an aleo address object from a string representation of an address
   *
   * @param {string} address String representation of an addressm
   * @returns {Address} Address
   */
  static from_string(network: string, address: string): Address;
  /**
   * Get a string representation of an Aleo address object
   *
   * @param {Address} Address
   * @returns {string} String representation of the address
   */
  to_string(): string;
  to_x_coordinate(): string;
}
export class DecryptTransition {
  private constructor();
  free(): void;
  static owns_transition(network: string, view_key: ViewKey, tpk_str: string, tcm_str: string): boolean;
  static decrypt_ciphertext(network: string, view_key: ViewKey, ciphertext_str: string, tpk_str: string, program_id: string, function_name_str: string, index: number): string;
  static decrypt_transition(network: string, view_key: ViewKey, transition_str: string): string;
  static decrypt_transition_with_tvk(network: string, tvk_str: string, transition_str: string): string;
  static generate_tvk(network: string, view_key: ViewKey, tpk_str: string): string;
}
export class Field {
  private constructor();
  free(): void;
  toString(): string;
  static fromString(network: string, field: string): Field;
  static bhp256_hash_to_field(network: string, hash: Uint8Array): Field;
}
export class Group {
  private constructor();
  free(): void;
  toString(): string;
  static fromString(network: string, group: string): Group;
}
/**
 * Key pair object containing both the function proving and verifying keys
 */
export class KeyPair {
  free(): void;
  /**
   * Create new key pair from proving and verifying keys
   *
   * @param {ProvingKey} proving_key Proving key corresponding to a function in an Aleo program
   * @param {VerifyingKey} verifying_key Verifying key corresponding to a function in an Aleo program
   * @returns {KeyPair} Key pair object containing both the function proving and verifying keys
   */
  constructor(proving_key: ProvingKey, verifying_key: VerifyingKey);
  /**
   * Get the proving key. This method will remove the proving key from the key pair
   *
   * @returns {ProvingKey | Error}
   */
  provingKey(): ProvingKey;
  /**
   * Get the verifying key. This method will remove the verifying key from the key pair
   *
   * @returns {VerifyingKey | Error}
   */
  verifyingKey(): VerifyingKey;
}
export class Plaintext {
  private constructor();
  free(): void;
  toString(): string;
  static fromString(network: string, plaintext: string): Plaintext;
  hashBhp256(): string;
  hashBhp256ToAddress(): string;
}
/**
 * Private key of an Aleo account
 */
export class PrivateKey {
  free(): void;
  /**
   * Generate a new private key using a cryptographically secure random number generator
   *
   * @returns {PrivateKey}
   */
  constructor(network: string);
  /**
   * Get a private key from a series of unchecked bytes
   *
   * @param {Uint8Array} seed Unchecked 32 byte long Uint8Array acting as the seed for the private key
   * @returns {PrivateKey}
   */
  static from_seed_unchecked(network: string, seed: Uint8Array): PrivateKey;
  /**
   * Get a private key from a string representation of a private key
   *
   * @param {string} seed String representation of a private key
   * @returns {PrivateKey}
   */
  static from_string(network: string, private_key: string): PrivateKey;
  /**
   * Get a string representation of the private key. This function should be used very carefully
   * as it exposes the private key plaintext
   *
   * @returns {string} String representation of a private key
   */
  to_string(): string;
  /**
   * Get the view key corresponding to the private key
   *
   * @returns {ViewKey}
   */
  to_view_key(): ViewKey;
  /**
   * Get the address corresponding to the private key
   *
   * @returns {Address}
   */
  to_address(): Address;
  /**
   * Sign a message with the private key
   *
   * @param {Uint8Array} Byte array representing a message signed by the address
   * @returns {Signature} Signature generated by signing the message with the address
   */
  sign(message: Uint8Array): Signature;
}
/**
 * Webassembly Representation of an Aleo program
 */
export class Program {
  private constructor();
  free(): void;
  /**
   * Create a program from a program string
   *
   * @param {string} program Aleo program source code
   * @returns {Program | Error} Program object
   */
  static fromString(network: string, program: string): Program;
  /**
   * Get a string representation of the program
   *
   * @returns {string} String containing the program source code
   */
  toString(): string;
  toAddress(): string;
  static programIdToAddress(network: string, program_id: string): string;
  /**
   * Determine if a function is present in the program
   *
   * @param {string} functionName Name of the function to check for
   * @returns {boolean} True if the program is valid, false otherwise
   */
  hasFunction(function_name: string): boolean;
  /**
   * Get javascript array of functions names in the program
   *
   * @returns {Array} Array of all function names present in the program
   *
   * @example
   * const expected_functions = [
   *   "mint",
   *   "transfer_private",
   *   "transfer_private_to_public",
   *   "transfer_public",
   *   "transfer_public_to_private",
   *   "join",
   *   "split",
   *   "fee"
   * ]
   *
   * const credits_program = aleo_wasm.Program.getCreditsProgram();
   * const credits_functions = credits_program.getFunctions();
   * console.log(credits_functions === expected_functions); // Output should be "true"
   */
  getFunctions(): Array<any>;
  /**
   * Get a javascript object representation of the function inputs and types. This can be used
   * to generate a web form to capture user inputs for an execution of a function.
   *
   * @param {string} function_name Name of the function to get inputs for
   * @returns {Array | Error} Array of function inputs
   *
   * @example
   * const expected_inputs = [
   *     {
   *       type:"record",
   *       visibility:"private",
   *       record:"credits",
   *       members:[
   *         {
   *           name:"microcredits",
   *           type:"u64",
   *           visibility:"private"
   *         }
   *       ],
   *       register:"r0"
   *     },
   *     {
   *       type:"address",
   *       visibility:"private",
   *       register:"r1"
   *     },
   *     {
   *       type:"u64",
   *       visibility:"private",
   *       register:"r2"
   *     }
   * ];
   *
   * const credits_program = aleo_wasm.Program.getCreditsProgram();
   * const transfer_function_inputs = credits_program.getFunctionInputs("transfer_private");
   * console.log(transfer_function_inputs === expected_inputs); // Output should be "true"
   */
  getFunctionInputs(function_name: string): Array<any>;
  /**
   * Get a the list of a program's mappings and the names/types of their keys and values.
   *
   * @returns {Array | Error} - An array of objects representing the mappings in the program
   * @example
   * const expected_mappings = [
   *    {
   *       name: "account",
   *       key_name: "owner",
   *       key_type: "address",
   *       value_name: "microcredits",
   *       value_type: "u64"
   *    }
   * ]
   *
   * const credits_program = aleo_wasm.Program.getCreditsProgram();
   * const credits_mappings = credits_program.getMappings();
   * console.log(credits_mappings === expected_mappings); // Output should be "true"
   */
  getMappings(): Array<any>;
  /**
   * Get a javascript object representation of a program record and its types
   *
   * @param {string} record_name Name of the record to get members for
   * @returns {Object | Error} Object containing the record name, type, and members
   *
   * @example
   *
   * const expected_record = {
   *     type: "record",
   *     record: "Credits",
   *     members: [
   *       {
   *         name: "owner",
   *         type: "address",
   *         visibility: "private"
   *       },
   *       {
   *         name: "microcredits",
   *         type: "u64",
   *         visibility: "private"
   *       }
   *     ];
   *  };
   *
   * const credits_program = aleo_wasm.Program.getCreditsProgram();
   * const credits_record = credits_program.getRecordMembers("Credits");
   * console.log(credits_record === expected_record); // Output should be "true"
   */
  getRecordMembers(record_name: string): object;
  /**
   * Get a javascript object representation of a program struct and its types
   *
   * @param {string} struct_name Name of the struct to get members for
   * @returns {Array | Error} Array containing the struct members
   *
   * @example
   *
   * const STRUCT_PROGRAM = "program token_issue.aleo;
   *
   * struct token_metadata:
   *     network as u32;
   *     version as u32;
   *
   * struct token:
   *     token_id as u32;
   *     metadata as token_metadata;
   *
   * function no_op:
   *    input r0 as u64;
   *    output r0 as u64;"
   *
   * const expected_struct_members = [
   *    {
   *      name: "token_id",
   *      type: "u32",
   *    },
   *    {
   *      name: "metadata",
   *      type: "struct",
   *      struct_id: "token_metadata",
   *      members: [
   *       {
   *         name: "network",
   *         type: "u32",
   *       }
   *       {
   *         name: "version",
   *         type: "u32",
   *       }
   *     ]
   *   }
   * ];
   *
   * const program = aleo_wasm.Program.fromString(STRUCT_PROGRAM);
   * const struct_members = program.getStructMembers("token");
   * console.log(struct_members === expected_struct_members); // Output should be "true"
   */
  getStructMembers(struct_name: string): Array<any>;
  /**
   * Get the credits.aleo program
   *
   * @returns {Program} The credits.aleo program
   */
  static getCreditsProgram(network: string): Program;
  /**
   * Get the id of the program
   *
   * @returns {string} The id of the program
   */
  id(): string;
  /**
   * Determine equality with another program
   *
   * @param {Program} other The other program to compare
   * @returns {boolean} True if the programs are equal, false otherwise
   */
  isEqual(other: Program): boolean;
  /**
   * Get program_imports
   *
   * @returns {Array} The program imports
   *
   * @example
   *
   * const DOUBLE_TEST = "import multiply_test.aleo;
   *
   * program double_test.aleo;
   *
   * function double_it:
   *     input r0 as u32.private;
   *     call multiply_test.aleo/multiply 2u32 r0 into r1;
   *     output r1 as u32.private;";
   *
   * const expected_imports = [
   *    "multiply_test.aleo"
   * ];
   *
   * const program = aleo_wasm.Program.fromString(DOUBLE_TEST_PROGRAM);
   * const imports = program.getImports();
   * console.log(imports === expected_imports); // Output should be "true"
   */
  getImports(): Array<any>;
}
export class ProgramManager {
  private constructor();
  free(): void;
  /**
   * Estimate the component of the deployment cost which comes from the fee for the program name.
   * Note that this cost does not represent the entire cost of deployment. It is additional to
   * the cost of the size (in bytes) of the deployment.
   *
   * Disclaimer: Fee estimation is experimental and may not represent a correct estimate on any current or future network
   *
   * @param name The name of the program to be deployed
   * @returns {u64 | Error}
   */
  static estimateProgramNameCost(name: string): bigint;
  static deploy_transaction(private_key: PrivateKey, program: string, imports: object | null | undefined, fee_credits: number, fee_record: RecordPlaintext | null | undefined, url: string, fee_proving_key: ProvingKey | null | undefined, fee_verifying_key: VerifyingKey | null | undefined, inclusion_key: ProvingKey): Promise<Transaction>;
  static authorize_deploy(private_key: PrivateKey, deployment: string, fee_credits: number, fee_record?: RecordPlaintext | null): Promise<string>;
  static synthesize(network: string, program_string: string, _function: string, imports?: object | null): KeyPair;
  static execute_transaction(private_key: PrivateKey, program: string, _function: string, inputs: Array<any>, fee_credits: number, fee_record: RecordPlaintext | null | undefined, url: string, imports: object | null | undefined, proving_key: ProvingKey | null | undefined, verifying_key: VerifyingKey | null | undefined, fee_proving_key: ProvingKey | null | undefined, fee_verifying_key: VerifyingKey | null | undefined, inclusion_key: ProvingKey): Promise<Transaction>;
  static authorize_transaction(private_key: PrivateKey, program: string, _function: string, inputs: Array<any>, fee_credits: number, fee_record?: RecordPlaintext | null, imports?: object | null): Promise<string>;
  static execute_authorization(authorization: string, fee_authorization: string | null | undefined, program: string, _function: string, url: string, imports: object | null | undefined, proving_key: ProvingKey | null | undefined, verifying_key: VerifyingKey | null | undefined, fee_proving_key: ProvingKey | null | undefined, fee_verifying_key: VerifyingKey | null | undefined, inclusion_key: ProvingKey): Promise<Transaction>;
  static build_execution(private_key: PrivateKey, program: string, _function: string, inputs: Array<any>, url: string, imports: object | null | undefined, proving_key: ProvingKey | null | undefined, verifying_key: VerifyingKey | null | undefined, inclusion_key: ProvingKey): Promise<string>;
  static estimateExecutionFee(network: string, transaction: string, program: string, _function: string, imports?: object | null): Promise<bigint>;
}
/**
 * Proving key for a function within an Aleo program
 */
export class ProvingKey {
  private constructor();
  free(): void;
  /**
   * Return the checksum of the proving key
   *
   * @returns {string} Checksum of the proving key
   */
  checksum(): string;
  /**
   * Create a copy of the proving key
   *
   * @returns {ProvingKey} A copy of the proving key
   */
  copy(): ProvingKey;
  /**
   * Construct a new proving key from a byte array
   *
   * @param {Uint8Array} bytes Byte array representation of a proving key
   * @returns {ProvingKey | Error}
   */
  static fromBytes(network: string, bytes: Uint8Array): ProvingKey;
  /**
   * Create a proving key from string
   *
   * @param {string | Error} String representation of the proving key
   */
  static fromString(network: string, string: string): ProvingKey;
  /**
   * Return the byte representation of a proving key
   *
   * @returns {Uint8Array | Error} Byte array representation of a proving key
   */
  toBytes(): Uint8Array;
  /**
   * Get a string representation of the proving key
   *
   * @returns {string} String representation of the proving key
   */
  toString(): string;
}
/**
 * Encrypted Aleo record
 */
export class RecordCiphertext {
  private constructor();
  free(): void;
  /**
   * Create a record ciphertext from a string
   *
   * @param {string} record String representation of a record ciphertext
   * @returns {RecordCiphertext | Error} Record ciphertext
   */
  static fromString(network: string, record: string): RecordCiphertext;
  /**
   * Return the string reprensentation of the record ciphertext
   *
   * @returns {string} String representation of the record ciphertext
   */
  toString(): string;
  /**
   * Decrypt the record ciphertext into plaintext using the view key. The record will only
   * decrypt if the record was encrypted by the account corresponding to the view key
   *
   * @param {ViewKey} view_key View key used to decrypt the ciphertext
   * @returns {RecordPlaintext | Error} Record plaintext object
   */
  decrypt(view_key: ViewKey): RecordPlaintext;
  /**
   * Determines if the account corresponding to the view key is the owner of the record
   *
   * @param {ViewKey} view_key View key used to decrypt the ciphertext
   * @returns {boolean}
   */
  isOwner(view_key: ViewKey): boolean;
  getOwnerX(): string;
  getNonceX(): string;
  getNonceY(): string;
}
/**
 * Plaintext representation of an Aleo record
 */
export class RecordPlaintext {
  private constructor();
  free(): void;
  commitment(program_id: string, record_name: string): Field;
  /**
   * Return a record plaintext from a string.
   *
   * @param {string} record String representation of a plaintext representation of an Aleo record
   * @returns {RecordPlaintext | Error} Record plaintext
   */
  static fromString(network: string, record: string): RecordPlaintext;
  /**
   * Returns the record plaintext string
   *
   * @returns {string} String representation of the record plaintext
   */
  toString(): string;
  /**
   * Returns the amount of microcredits in the record
   *
   * @returns {u64} Amount of microcredits in the record
   */
  microcredits(): bigint;
  /**
   * Returns the nonce of the record. This can be used to uniquely identify a record.
   *
   * @returns {string} Nonce of the record
   */
  nonce(): string;
  /**
   * Attempt to get the serial number of a record to determine whether or not is has been spent
   *
   * @param {PrivateKey} private_key Private key of the account that owns the record
   * @param {string} program_id Program ID of the program that the record is associated with
   * @param {string} record_name Name of the record
   * @returns {string | Error} Serial number of the record
   */
  serialNumberString(private_key: PrivateKey, program_id: string, record_name: string): string;
}
/**
 * Cryptographic signature of a message signed by an Aleo account
 */
export class Signature {
  private constructor();
  free(): void;
  /**
   * Sign a message with a private key
   *
   * @param {PrivateKey} private_key The private key to sign the message with
   * @param {Uint8Array} message Byte representation of the message to sign
   * @returns {Signature} Signature of the message
   */
  static sign(private_key: PrivateKey, message: Uint8Array): Signature;
  static sign_plaintext(network: string, private_key: string, message: string): Signature;
  /**
   * Verify a signature of a message with an address
   *
   * @param {Address} address The address to verify the signature with
   * @param {Uint8Array} message Byte representation of the message to verify
   * @returns {boolean} True if the signature is valid, false otherwise
   */
  verify(address: Address, message: Uint8Array): boolean;
  /**
   * Get a signature from a string representation of a signature
   *
   * @param {string} signature String representation of a signature
   * @returns {Signature} Signature
   */
  static from_string(network: string, signature: string): Signature;
  /**
   * Get a string representation of a signature
   *
   * @returns {string} String representation of a signature
   */
  to_string(): string;
}
/**
 * Webassembly Representation of an Aleo transaction
 *
 * This object is created when generating an on-chain function deployment or execution and is the
 * object that should be submitted to the Aleo Network in order to deploy or execute a function.
 */
export class Transaction {
  private constructor();
  free(): void;
  /**
   * Create a transaction from a string
   *
   * @param {string} transaction String representation of a transaction
   * @returns {Transaction | Error}
   */
  static fromString(network: string, transaction: string): Transaction;
  /**
   * Get the transaction as a string. If you want to submit this transaction to the Aleo Network
   * this function will create the string that should be submitted in the `POST` data.
   *
   * @returns {string} String representation of the transaction
   */
  toString(): string;
  /**
   * Get the id of the transaction. This is the merkle root of the transaction's inclusion proof.
   *
   * This value can be used to query the status of the transaction on the Aleo Network to see
   * if it was successful. If successful, the transaction will be included in a block and this
   * value can be used to lookup the transaction data on-chain.
   *
   * @returns {string} Transaction id
   */
  transactionId(): string;
  /**
   * Get the type of the transaction (will return "deploy" or "execute")
   *
   * @returns {string} Transaction type
   */
  transactionType(): string;
}
/**
 * Verifying key for a function within an Aleo program
 */
export class VerifyingKey {
  private constructor();
  free(): void;
  /**
   * Get the checksum of the verifying key
   *
   * @returns {string} Checksum of the verifying key
   */
  checksum(): string;
  /**
   * Create a copy of the verifying key
   *
   * @returns {VerifyingKey} A copy of the verifying key
   */
  copy(): VerifyingKey;
  /**
   * Construct a new verifying key from a byte array
   *
   * @param {Uint8Array} bytes Byte representation of a verifying key
   * @returns {VerifyingKey | Error}
   */
  static fromBytes(network: string, bytes: Uint8Array): VerifyingKey;
  /**
   * Create a verifying key from string
   *
   * @param {String} string String representation of a verifying key
   * @returns {VerifyingKey | Error}
   */
  static fromString(network: string, string: string): VerifyingKey;
  /**
   * Create a byte array from a verifying key
   *
   * @returns {Uint8Array | Error} Byte representation of a verifying key
   */
  toBytes(): Uint8Array;
  /**
   * Get a string representation of the verifying key
   *
   * @returns {String} String representation of the verifying key
   */
  toString(): string;
}
export class ViewKey {
  private constructor();
  free(): void;
  /**
   * Create a new view key from a private key
   *
   * @param {PrivateKey} private_key Private key
   * @returns {ViewKey} View key
   */
  static from_private_key(network: string, private_key: PrivateKey): ViewKey;
  /**
   * Create a new view key from a string representation of a view key
   *
   * @param {string} view_key String representation of a view key
   * @returns {ViewKey} View key
   */
  static from_string(network: string, view_key: string): ViewKey;
  is_owner(address_x_coordinate: string, record_nonce: string, record_owner_x_coordinate: string): boolean;
  is_owner_precompute(address_x_coordinate: string, record_nonce: string, record_owner_x_coordinate: string): boolean;
  to_scalar(): string;
  /**
   * Get a string representation of a view key
   *
   * @returns {string} String representation of a view key
   */
  to_string(): string;
  /**
   * Get the address corresponding to a view key
   *
   * @returns {Address} Address
   */
  to_address(): Address;
  /**
   * Decrypt a record ciphertext with a view key
   *
   * @param {string} ciphertext String representation of a record ciphertext
   * @returns {string} String representation of a record plaintext
   */
  decrypt(ciphertext: string): string;
  readonly network: string;
}